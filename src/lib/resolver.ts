import { Query, from, HierarchyProvider, HierarchyQuery } from "iterable-query";
import { CommandLineOptionSet, CommandLineOption, CommandLineValueMap, CommandLineUnspecifiedOption, CommandLineOptionMap, CommandLineCommand, CommandLineParseError, CommandLineParseErrorDefinition, CommandLineSettings, CommandLineOptionSets, ParsedArgumentType, CommandLineCommandMap, CommandLineAlias, CommandLineVisibility, CommandLineDefaultValueCallback, CommandLineValidateCallback, CommandLineConvertCallback, CommandLineErrorCallback, CommandPath, CommandLineExecCallback, ParsedCommandLine } from "./types";
import { compareValues, isObjectLike, valuesOrDefault, valueOrDefault, Lazy, walkCommandPath, toCommandPath } from "./utils";

const commandHierarchy: HierarchyProvider<Command> = {
    parent(command) { return command.parentCommand; },
    children(command) { return command.getCommands(); }
};

export class OptionSet {
    public readonly rawOptionSet: CommandLineOptionSet;
    public readonly parentResolver: Resolver;
    public readonly parentCommand: Command | undefined;
    public readonly key: string;
    public readonly setName: string;
    public readonly merge: boolean;
    public readonly include: ReadonlyArray<string>;
    private readonly _lazyVisibility: Lazy<CommandLineVisibility>;

    constructor(parent: Resolver, key: string, rawOptionSet: CommandLineOptionSet) {
        this.rawOptionSet = rawOptionSet;
        this.parentResolver = parent;
        this.parentCommand = asCommand(parent);
        this.key = key;
        this.setName = valueOrDefault(rawOptionSet.setName, key);
        this.merge = valueOrDefault(rawOptionSet.merge, false);
        this.include = valuesOrDefault(rawOptionSet.include);
        this._lazyVisibility = Lazy.from(resolveVisibility, rawOptionSet, this.parentCommand);
    }

    public get visibility(): CommandLineVisibility {
        return this._lazyVisibility.value;
    }

    public static compare(x: OptionSet | undefined, y: OptionSet | undefined) {
        if (x === y) return 0;
        if (x === undefined) return -1;
        if (y === undefined) return +1;
        return compareValues(x.setName, y.setName);
    }

    public compareTo(other: OptionSet | undefined) {
        return OptionSet.compare(this, other);
    }
}

export class Option {
    public readonly rawOption: CommandLineOption;
    public readonly parentResolver: Resolver;
    public readonly parentOptionSet: OptionSet | undefined;
    public readonly parentCommand: Command | undefined;
    public readonly key: string;
    public readonly type: "boolean" | "number" | "string";
    public readonly longName?: string;
    public readonly shortName?: string;
    public readonly parameterName: string;
    public readonly aliases: ReadonlyArray<string>;
    public readonly aliasFor?: ReadonlyArray<string>;
    public readonly position?: number;
    public readonly required: boolean;
    public readonly help: boolean;
    public readonly single: boolean;
    public readonly multiple: boolean | "no-comma" /*deprecated*/ | "comma-separated";
    public readonly passthru: boolean;
    public readonly rest: boolean;
    public readonly groups: ReadonlyArray<string>;
    public readonly param?: string;
    public readonly description?: string;
    public readonly hasValidator: boolean;
    public readonly hasConverter: boolean;
    public readonly hasCustomError: boolean;
    public readonly hasDefaultValue: boolean;
    public readonly defaultValue?: ParsedArgumentType;
    public readonly autoGenerated: boolean;

    private readonly _lazyVisibility: Lazy<CommandLineVisibility>;
    private readonly _sortKey: string;
    private readonly _map?: CommandLineValueMap<string | number>;
    private readonly _caseInsensitiveMap?: CommandLineValueMap<string | number>;
    private readonly _in?: (string | number)[];
    private readonly _caseInsensitiveIn?: string[];
    private readonly _match?: RegExp;
    private readonly _validateCallback?: CommandLineValidateCallback<any>;
    private readonly _convertCallback?: CommandLineConvertCallback<any>;
    private readonly _errorCallback?: CommandLineErrorCallback;
    private readonly _error?: CommandLineParseErrorDefinition | string;
    private readonly _defaultValueCallback?: CommandLineDefaultValueCallback<ParsedArgumentType>;

    constructor(parent: Resolver, optionSet: OptionSet | undefined, key: string, rawOption: CommandLineOption);
    /** @internal */
    constructor(parent: Resolver, optionSet: OptionSet | undefined, key: string, rawOption: CommandLineOption, autoGenerated?: boolean);
    constructor(parent: Resolver, optionSet: OptionSet | undefined, key: string, rawOption: CommandLineUnspecifiedOption, autoGenerated = false) {
        if (typeof key !== "string" || !key) throw Errors.invalidKey(key);
        if (!isObjectLike(rawOption)) throw Errors.invalidRawObject(key, "CommandLineOption");

        const type = inferType(rawOption);
        checkCommandLineOption(key, type, rawOption);

        this.autoGenerated = autoGenerated;
        this.rawOption = rawOption;
        this.parentResolver = parent;
        this.parentCommand = asCommand(parent);
        this.parentOptionSet = optionSet;
        this.key = key;
        this.type = type;
        this.aliasFor = rawOption.aliasFor !== undefined ? valuesOrDefault(rawOption.aliasFor) : undefined;

        this.longName =
            rawOption.longName !== null ? normalizeNameCS(valueOrDefault(rawOption.longName, key)) :
            rawOption.shortName ? undefined :
            normalizeNameCS(key);

        this.shortName =
            rawOption.shortName ? rawOption.shortName.trim() :
            undefined;

        this.parameterName =
            rawOption.passthru ? "--" :
            this.longName ? `--${this.longName}` :
            `-${this.shortName}`;

        this._sortKey =
            this.shortName && this.longName ? `${this.shortName} ${this.longName}` :
            this.shortName ? this.shortName :
            this.longName ? this.longName :
            "";

        this.aliases = valuesOrDefault(rawOption.alias, normalizeNameCS);
        this.position = rawOption.position;
        this.required = rawOption.required || false;
        this.help = rawOption.help || false;
        this.single = rawOption.single || false;
        this.passthru = rawOption.passthru || false;
        this.rest = rawOption.rest || false;
        this.multiple = rawOption.multiple || this.rest || this.passthru;
        this.groups = valuesOrDefault(rawOption.group, /*copy*/ true);
        this.param = valueOrDefault(rawOption.param, type !== "boolean" ? type : undefined);
        this.description = rawOption.description;
        this._map = rawOption.map;
        this._caseInsensitiveMap = rawOption.ignoreCase && this._map ? toCaseInsensitiveCommandLineValueMap(this._map) : undefined;
        this._in = rawOption.in ? rawOption.in.slice() : undefined;
        this._caseInsensitiveIn = rawOption.ignoreCase && this._in && type === "string" ? this._in.map(v => String(v).toUpperCase()) : undefined;
        this._validateCallback = rawOption.validate;
        this._convertCallback = rawOption.convert;
        this._errorCallback = typeof rawOption.error === "function" ? rawOption.error : undefined;
        this._error = typeof rawOption.error !== "function" ? rawOption.error : undefined;
        this._match = typeof rawOption.match === "string" ? new RegExp(rawOption.match, rawOption.ignoreCase ? "i" : undefined) : rawOption.match;
        this._defaultValueCallback = typeof rawOption.defaultValue === "function" ? rawOption.defaultValue : undefined;
        this.defaultValue = typeof rawOption.defaultValue !== "function" ? rawOption.defaultValue : undefined;

        this.hasDefaultValue =
            this.defaultValue !== undefined ||
            this._defaultValueCallback !== undefined;

        this.hasValidator =
            this._validateCallback !== undefined ||
            this._match !== undefined ||
            this._in !== undefined ||
            this._map !== undefined;

        this.hasConverter =
            this._convertCallback !== undefined ||
            this._map !== undefined;

        this.hasCustomError =
            this._errorCallback !== undefined ||
            this._error !== undefined;

        this._lazyVisibility = Lazy.from(resolveVisibility, rawOption, optionSet);
    }

    public static compare(x: Option | undefined, y: Option | undefined): number {
        if (x === y) return 0;
        if (x === undefined) return -1;
        if (y === undefined) return +1;
        return compareValues(x._sortKey, y._sortKey);
    }

    public static comparePositions(x: Option | undefined, y: Option | undefined): number {
        if (x === y) return 0;
        if (x === undefined) return -1;
        if (y === undefined) return +1;
        if (x.position === y.position) return 0;
        if (x.position === undefined) return +1;
        if (y.position === undefined) return -1;
        return compareValues(x.position, y.position);
    }

    public get visibility(): CommandLineVisibility {
        return this._lazyVisibility.value;
    }

    public isRest(): this is RestOption {
        return this.rest;
    }

    public isPassthru(): this is PassthruOption {
        return this.passthru;
    }

    public isHelp(): this is HelpOption {
        return this.help;
    }

    public compare(other: Option | undefined): number {
        return Option.compare(this, other);
    }

    public validate(value: boolean | number | string, parameterName: string, parsedArgs: any): CommandLineParseError | undefined {
        if (typeof this._validateCallback === "function") {
            const result = this._validateCallback.call(this.rawOption, value, parameterName, parsedArgs);
            if (result) {
                return result;
            }
        }

        if (this._match && typeof value === "string") {
            if (!this._match.test(value)) {
                return new CommandLineParseError(`Option '${parameterName}' was not valid.`);
            }
        }

        if (this._map && typeof value === "string") {
            if (!Object.prototype.hasOwnProperty.call(this._map, value)) {
                if (!this._caseInsensitiveMap || !Object.prototype.hasOwnProperty.call(this._caseInsensitiveMap, value.toUpperCase())) {
                    return new CommandLineParseError(`Option '${parameterName}' was not valid.`);
                }
            }
        }

        if (this._in && typeof value !== "boolean") {
            if (this._in.indexOf(value) === -1) {
                if (!this._caseInsensitiveIn || typeof value !== "string" || this._caseInsensitiveIn.indexOf(value.toUpperCase()) === -1) {
                    return new CommandLineParseError(`Option '${parameterName}' was not valid.`);
                }
            }
        }
    }

    public convert(value: string, arg: string): string | number | boolean {
        if (!this._convertCallback && !this._map) throw Errors.noConversionDefined(this.key);
        let result: any = value;
        if (this._convertCallback) {
            result = this._convertCallback.call(this.rawOption, value, arg);
        }
        if (this._map) {
            if (Object.prototype.hasOwnProperty.call(this._map, result)) {
                result = this._map[result];
            }
            else if (this._caseInsensitiveMap) {
                const key = String(result).toUpperCase();
                if (Object.prototype.hasOwnProperty.call(this._caseInsensitiveMap, key)) {
                    result = this._caseInsensitiveMap[key];
                }
            }
        }
        return result;
    }

    public error(arg: string, error: CommandLineParseError): CommandLineParseError {
        if (this._errorCallback) {
            return this._errorCallback.call(this.rawOption, arg, error) || error;
        }
        else if (typeof this._error === "object") {
            return new CommandLineParseError(this._error.message, this._error.help, this._error.status);
        }
        else if (typeof this._error === "string") {
            return new CommandLineParseError(this._error, /*help*/ true);
        }
        return error;
    }

    public getDefaultValue(parsedArgs: any, group: string | undefined): ParsedArgumentType | undefined {
        if (this._defaultValueCallback) {
            return this._defaultValueCallback.call(this.rawOption, parsedArgs, group);
        }
        return this.defaultValue;
    }

    public toUsageString(): string {
        let usage = this.parameterName;
        if (this.type !== "boolean" && !this.passthru) {
            if (this.position !== undefined || this.rest) {
                usage = `[${usage}]`;
            }

            let param = this.param || this.type;
            if (this.multiple) {
                param += "[]";
            }

            usage += ` <${param}>`;
        }
        if (!this.required) {
            usage = `[${usage}]`;
        }
        return usage;
    }
}

export type PassthruOption = Option & {
    passthru: true;
};

export type RestOption = Option & {
    rest: true;
};

export type HelpOption = Option & {
    help: true;
};

export interface ResolverData {
    optionSets?: CommandLineOptionSets;
    options?: CommandLineOptionMap;
    defaultGroup?: string;
    commands?: CommandLineCommandMap;
    include?: string | ReadonlyArray<string>;
}

export class Resolver {
    public readonly parentResolver: Resolver | undefined;
    public readonly groups: ReadonlyArray<string>;

    private readonly _keyMap = new Map<string | symbol, Option>();
    private readonly _shortNameMap = new Map<string, Option>();
    private readonly _longNameMap = new Map<string, Option>();
    private readonly _positionMap = new Map<number, Option[]>();
    private readonly _options: Option[] = [];
    private readonly _groupsSet = new Set<string>();
    private readonly _groups: string[] = [];
    private readonly _optionSets = new Map<string, OptionSet>();
    private readonly _commandMap = new Map<string, Command>();
    private readonly _commands: Command[] = [];
    private _passthruOption: PassthruOption | undefined;
    private _restOption: RestOption | undefined;
    private _helpOption: HelpOption | undefined;
    private _helpCommand: HelpCommand | undefined;
    private _defaultGroup: string | undefined;

    constructor({ options, optionSets, commands, defaultGroup, include }: ResolverData, parent?: Resolver) {
        this.parentResolver = parent;
        this.groups = this._groups;
        this._defaultGroup = defaultGroup;
        if (options) this.addOptions(options);
        if (optionSets) this.addOptionSets(optionSets);
        if (commands) this.addCommands(commands);
        if (include) this.includeOptionSets(valuesOrDefault(include));
    }

    public getPassthruOption(own = false): PassthruOption | undefined {
        return this._passthruOption ? this._passthruOption :
            !own && this.parentResolver ? this.parentResolver.getPassthruOption(/*own*/ false) :
            undefined;
    }

    public getRestOption(own = false): RestOption | undefined {
        return this._restOption ? this._restOption :
            !own && this.parentResolver ? this.parentResolver.getRestOption(/*own*/ false) :
            undefined;
    }

    public getHelpOption(own = false): HelpOption | undefined {
        return this._helpOption ? this._helpOption :
            !own && this.parentResolver ? this.parentResolver.getHelpOption(/*own*/ false) :
            undefined;
    }

    public getHelpCommand(own = false): HelpCommand | undefined {
        return this._helpCommand ? this._helpCommand :
            !own && this.parentResolver ? this.parentResolver.getHelpCommand(/*own*/ false) :
            undefined;
    }

    public getDefaultGroup(): string | undefined {
        return this._defaultGroup
            || (this.parentResolver ? this.parentResolver.getDefaultGroup() : undefined);
    }

    public fromShortName(shortName: string): Option | undefined {
        return this._shortNameMap.get(shortName)
            || (this.parentResolver ? this.parentResolver.fromShortName(shortName) : undefined);
    }

    public fromLongName(longName: string): Option | undefined {
        return this._longNameMap.get(normalizeName(longName, /*caseInsensitive*/ true))
            || (this.parentResolver ? this.parentResolver.fromLongName(longName) : undefined);
    }

    public fromPosition(position: number): ReadonlyArray<Option> | undefined {
        return this._positionMap.get(position)
            || (this.parentResolver ? this.parentResolver.fromPosition(position) : undefined);
    }

    public has(key: string): boolean {
        return this._keyMap.has(key)
            || (this.parentResolver ? this.parentResolver.has(key) : false);
    }

    public get(key: string): Option | undefined {
        return this._keyMap.get(key)
            || (this.parentResolver ? this.parentResolver.get(key) : undefined);
    }

    public getShortName(key: string, includePrefix?: boolean): string | undefined {
        const option = this.get(key);
        if (!option || !option.shortName) return undefined;
        return includePrefix ? "-" + option.shortName : option.shortName;
    }

    public getLongName(key: string, includePrefix?: boolean): string | undefined {
        const option = this.get(key);
        if (!option || !option.longName) return undefined;
        return includePrefix ? "--" + option.longName : option.longName;
    }

    public getOwnOptions(group?: string): ReadonlyArray<Option> {
        return this._getOptions(group, /*own*/ true)
            .toArray();
    }

    public getOptions(group?: string): ReadonlyArray<Option> {
        return this._getOptions(group, /*own*/ false)
            .toArray();
    }

    public getDefaultOptions(group?: string): ReadonlyArray<Option> {
        return this._getOptions(group, /*own*/ false)
            .where(option => option.hasDefaultValue)
            .toArray();
    }

    public getRequiredOptions(group?: string): ReadonlyArray<Option> {
        return this._getOptions(group, /*own*/ false)
            .where(option => option.required)
            .toArray();
    }

    private _getOptions(group: string | undefined, own: boolean): Query<Option> {
        return from(this._options)
            .through(q =>
                group === undefined ? q.where(option => option.groups.length === 0) :
                group !== "*" ? q.where(option => option.groups.length === 0 || option.groups.indexOf(group!) !== -1) :
                q)
            .through(q =>
                !own && this.parentResolver ? q.union(this.parentResolver._getOptions(group, /*own*/ false)) :
                q);
    }

    public addOptions(options: CommandLineOptionMap, optionSet?: OptionSet): void {
        for (const key of Object.keys(options)) {
            const rawOption = options[key];
            this.addOption(key, rawOption, optionSet);
        }
    }

    public addOption(key: string, rawOption: CommandLineOption, optionSet?: OptionSet): Option;
    /** @internal */
    public addOption(key: string, rawOption: CommandLineOption, optionSet?: OptionSet, autoGenerated?: boolean): Option;
    public addOption(key: string, rawOption: CommandLineOption, optionSet?: OptionSet, autoGenerated?: boolean): Option {
        const option = new Option(this, optionSet, key, rawOption, autoGenerated);
        this._addOptionKey(key, option);
        if (option.isPassthru()) this._setPassthruOption(option);
        if (option.isRest()) this._setRestOption(option);
        if (option.isHelp()) this._setHelpOption(option);
        if (option.longName) this._addOptionLongName(option.longName, option, "long name");
        if (option.shortName) this._addOptionShortName(option.shortName, option, "short name");
        if (option.position !== undefined) this._addOptionPosition(option.position, option);
        this._addOptionAliases(option);
        this._addOptionGroups(option);
        this._options.push(option);
        return option;
    }

    protected _ensureHelpOption() {
        if (!this.getHelpOption()) {
            this.addOption("help", {
                description: "Prints this message.",
                type: "boolean",
                shortName: "h",
                longName: "help",
                alias: ["?"],
                help: true,
            }, undefined, /*autoGenerated*/ true);
        }
    }

    private _setPassthruOption(option: PassthruOption): void {
        if (this._passthruOption) throw Errors.duplicateKind("passthru option", option.key, this._passthruOption.key);
        this._passthruOption = option;
    }

    private _setRestOption(option: RestOption): void {
        if (this._restOption) throw Errors.duplicateKind("rest option", option.key, this._restOption.key);
        this._restOption = option;
    }

    private _setHelpOption(option: HelpOption): void {
        if (this._helpOption) throw Errors.duplicateKind("help option", option.key, this._helpOption.key);
        this._helpOption = option;
    }

    private _addOptionKey(key: string, option: Option): void {
        const existing = this._keyMap.get(key);
        if (existing) throw Errors.duplicateKey(key);
        this._keyMap.set(key, option);
    }

    private _addOptionLongName(longName: string, option: Option, kind: string): void {
        const caseInsensitiveLongName = normalizeName(longName, /*caseInsensitive*/ true);
        const existing = this._longNameMap.get(caseInsensitiveLongName);
        if (existing) {
            throw new Error(`Duplicate ${kind} '${longName}' for option '${option.key}' conflicts with previous definition '${existing.key}'.`);
        }

        this._longNameMap.set(caseInsensitiveLongName, option);
    }

    private _addOptionShortName(shortName: string, option: Option, kind: string): void {
        const existing = this._shortNameMap.get(shortName);
        if (existing) {
            throw new Error(`Duplicate ${kind} '${shortName}' for option '${option.key}' conflicts with previous definition '${existing.key}'.`);
        }

        this._shortNameMap.set(shortName, option);
    }

    private _addOptionAliases(option: Option): void {
        for (const alias of option.aliases) {
            if (alias.length === 1)
                this._addOptionShortName(alias, option, "alias");
            else
                this._addOptionLongName(alias, option, "alias");
        }
    }

    private _getOptionsForPosition(position: number): Option[] {
        let options = this._positionMap.get(position);
        if (options) return options;
        options = [];
        this._positionMap.set(position, options);
        return options;
    }

    private _addOptionPosition(position: number, option: Option): void {
        const options = this._getOptionsForPosition(position);
        if (option.groups.length === 0) {
            if (options.length > 0) throw Errors.duplicatePosition(option.key, options[0].key);
        }
        else {
            for (const existingOption of options) {
                if (existingOption.groups.length > 0) {
                    const intersection = Query.from(existingOption.groups).intersect(option.groups).toArray();
                    if (intersection) throw Errors.duplicatePositionWithGroups(option.key, existingOption.key, intersection);
                }
                else {
                    throw Errors.duplicatePosition(option.key, existingOption.key);
                }
            }
        }

        options.push(option);
    }

    private _addOptionGroups(option: Option): void {
        for (const group of option.groups) {
            if (!this._groupsSet.has(group)) {
                this._groupsSet.add(group);
                this._groups.push(group);
            }
        }
    }

    public addOptionSets(rawOptionSets: CommandLineOptionSets) {
        for (const key of Object.keys(rawOptionSets)) {
            const rawOptionSet = rawOptionSets[key];
            if (rawOptionSet) {
                this.addOptionSet(key, rawOptionSet);
            }
        }
    }

    public addOptionSet(key: string, rawOptionSet: CommandLineOptionSet) {
        const optionSet = new OptionSet(this, key, rawOptionSet);
        if (this._optionSets.has(key)) throw Errors.duplicateKey(key);
        this._optionSets.set(key, optionSet);
        return optionSet;
    }

    public getOptionSet(name: string, own = false): OptionSet | undefined {
        return this._optionSets.has(name) ? this._optionSets.get(name) :
            !own && this.parentResolver ? this.parentResolver.getOptionSet(name) :
            undefined;
    }

    public includeOptionSets(include: Iterable<string>): void {
        if (include) {
            this._includeOptionSetsWorker(include, new Set<string>());
        }
    }

    private _includeOptionSetsWorker(include: Iterable<string>, includedSets: Set<string>): void {
        for (const name of include) {
            if (!includedSets.has(name)) {
                includedSets.add(name);
                const optionSet = this.getOptionSet(name);
                if (optionSet) {
                    if (optionSet.rawOptionSet.options) {
                        this.addOptions(optionSet.rawOptionSet.options, optionSet);
                    }
                    this._includeOptionSetsWorker(optionSet.include, includedSets);
                }
            }
        }
    }

    public get hasCommands(): boolean {
        return this._commands.length > 0;
    }

    public findCommand(commandPath: string | CommandPath): Command | undefined {
        const result = walkCommandPath(this, toCommandPath(commandPath), /*resolveAliases*/ false);
        return result.found ? result.command : undefined;
    }

    public getCommand(commandName: string): Command | undefined {
        return this._commandMap.get(normalizeName(commandName, /*caseInsensitive*/ true));
    }

    public getCommands(): ReadonlyArray<Command> {
        return this._commands.slice();
    }

    public addCommands(rawCommands: CommandLineCommandMap): void {
        for (const key of Object.keys(rawCommands)) {
            const rawCommand = rawCommands[key];
            if (rawCommand) {
                this.addCommand(key, rawCommand);
            }
        }
    }

    public addCommand(key: string, rawCommand: CommandLineCommand): Command;
    /** @internal */
    public addCommand(key: string, rawCommand: CommandLineCommand, autoGenerated?: boolean): Command;
    public addCommand(key: string, rawCommand: CommandLineCommand, autoGenerated?: boolean): Command {
        const command = new Command(this, key, rawCommand, autoGenerated);
        this._addCommandName(command.commandName, command, "command name");
        if (command.isHelp()) this._setHelpCommand(command);
        this._addCommandAliases(command);
        this._commands.push(command);
        return command;
    }

    protected _ensureHelpCommand() {
        // Ensure a help command
        const helpCommand = this.getHelpCommand();
        if (!helpCommand) {
            this.addCommand("help", {
                summary: "Prints the help text associated with a command.",
                description: "Prints the help text associated with a command.",
                help: true,
                hidden: true,
                options: {
                    "commandPath": {
                        description: "The name of the command",
                        longName: "command",
                        alias: ["commandName", "commandPath"],
                        type: "string",
                        position: 0,
                        rest: true
                    },
                    "examples": {
                        description: "Whether to show examples",
                        type: "boolean"
                    },
                    "advanced": {
                        description: "Whether to show advanced help",
                        type: "boolean"
                    },
                    "full": {
                        description: "Whether to show examples and advanced help",
                        type: "boolean"
                    }
                }
            }, /*autoGenerated*/ true);
        }
        else if (!helpCommand.autoGenerated) {
            const commandPath = helpCommand.get("commandPath");
            if (!commandPath) throw new Error(`Help command '${helpCommand.key}' missing required option 'commandPath'.`);
            if (commandPath.type !== "string" || !commandPath.multiple) throw new Error(`Help command '${helpCommand.key}' has incorrectly specified option 'commandPath'.`);

            const examples = helpCommand.get("examples");
            if (!examples) throw new Error(`Help command '${helpCommand.key}' missing required option 'examples'.`);
            if (examples.type !== "boolean") throw new Error(`Help command '${helpCommand.key}' has incorrectly specified option 'examples'.`);

            const advanced = helpCommand.get("advanced");
            if (!advanced) throw new Error(`Help command '${helpCommand.key}' missing required option 'advanced'.`);
            if (advanced.type !== "boolean") throw new Error(`Help command '${helpCommand.key}' has incorrectly specified option 'advanced'.`);

            const full = helpCommand.get("full");
            if (!full) throw new Error(`Help command '${helpCommand.key}' missing required option 'full'.`);
            if (full.type !== "boolean") throw new Error(`Help command '${helpCommand.key}' has incorrectly specified option 'full'.`);
        }
    }

    private _addCommandName(commandName: string, command: Command, kind: string): void {
        commandName = normalizeName(commandName, /*caseInsensitive*/ true);
        const existing = this._commandMap.get(commandName);
        if (existing) throw Errors.duplicateCommand(kind, commandName, command.key, existing.key);
        this._commandMap.set(commandName, command);
    }

    private _addCommandAliases(command: Command): void {
        for (const alias of command.aliases) {
            this._addCommandName(alias, command, "alias");
        }
    }

    private _setHelpCommand(command: HelpCommand): void {
        if (this._helpCommand) throw Errors.duplicateKind("help command", command.key, this._helpCommand.key);
        this._helpCommand = command;
    }

    public async execute<T>(parsed: ParsedCommandLine<T>, context: any) {
        if (!parsed.handled) await this._invokePreExec(parsed, context);
        if (!parsed.handled) await this._invokeExec(parsed, context);
        if (parsed.handled) await this._invokePostExec(parsed, context);
    }

    protected async _invokePreExec(parsed: ParsedCommandLine<any>, context: any): Promise<void> {
        if (!parsed.handled && this.parentResolver) {
            await this.parentResolver._invokePreExec(parsed, context);
        }
    }

    protected async _invokeExec(parsed: ParsedCommandLine<any>, context: any): Promise<void> {
        if (!parsed.handled && this.parentResolver) {
            await this.parentResolver._invokeExec(parsed, context);
        }
    }

    protected async _invokePostExec(parsed: ParsedCommandLine<any>, context: any): Promise<void> {
        if (parsed.handled && this.parentResolver) {
            await this.parentResolver._invokePostExec(parsed, context);
        }
    }
}

export class CommandAlias {
    public readonly rawAlias: string | CommandPath | CommandLineAlias;
    public readonly parentResolver: Resolver;
    public readonly parentCommand: Command;
    public readonly commandPath: CommandPath;
    public readonly commandArguments: ReadonlyArray<string>;

    private readonly _lazyResolvedCommand: Lazy<Command>;

    constructor(parent: Command, rawAlias: string | CommandPath | CommandLineAlias) {
        this.rawAlias = rawAlias;
        this.parentResolver = parent;
        this.parentCommand = parent;
        this.commandPath =
            typeof rawAlias === "string" ? [rawAlias] :
            Array.isArray(rawAlias) ? rawAlias :
            valuesOrDefault(rawAlias.command, /*copy*/ true) as CommandPath;
        this.commandArguments = typeof rawAlias !== "string" && !Array.isArray(rawAlias) ? valuesOrDefault(rawAlias.args) : [];
        this._lazyResolvedCommand = Lazy.from(resolveCommandAlias, parent.parentResolver as Resolver, this.commandPath);
    }

    public get resolvedCommand() {
        return this._lazyResolvedCommand.value;
    }

    public getUnparsedArguments() {
        return [...this.commandPath, ...this.commandArguments];
    }
}

export class Command extends Resolver {
    public readonly rawCommand: CommandLineCommand;
    public readonly parentCommand: Command | undefined;
    public readonly key: string;
    public readonly commandName: string;
    public readonly aliases: ReadonlyArray<string>;
    public readonly aliasFor: CommandAlias | undefined;
    public readonly usages: ReadonlyArray<string>;
    public readonly examples: ReadonlyArray<string>;
    public readonly summary: string;
    public readonly help: boolean;
    public readonly description: string;
    public readonly container: boolean;
    public readonly autoGenerated: boolean;

    private readonly _preExec: CommandLineExecCallback | undefined;
    private readonly _postExec: CommandLineExecCallback | undefined;
    private readonly _exec: CommandLineExecCallback | undefined;
    private readonly _lazyVisibility: Lazy<CommandLineVisibility>;
    private readonly _lazyCommandPath: Lazy<CommandPath>;

    constructor(parent: Resolver, key: string, rawCommand: CommandLineCommand);
    /** @internal */
    constructor(parent: Resolver, key: string, rawCommand: CommandLineCommand, autoGenerated?: boolean);
    constructor(parent: Resolver, key: string, rawCommand: CommandLineCommand, autoGenerated = false) {
        if (typeof key !== "string" || !key) throw Errors.invalidKey(key);
        if (!isObjectLike(rawCommand)) throw Errors.invalidRawObject(key, "CommandLineCommand");
        checkCommandLineCommand(key, rawCommand);
        super(rawCommand, parent);
        this.autoGenerated = autoGenerated;
        this.rawCommand = rawCommand;
        this.parentCommand = asCommand(parent);
        this.key = key;
        this.commandName = normalizeName(valueOrDefault(rawCommand.commandName, key), /*caseInsensitive*/ false);
        this.aliases = valuesOrDefault(rawCommand.alias).map(alias => normalizeName(alias, /*caseInsensitive*/ false));
        this.aliasFor = rawCommand.aliasFor !== undefined ? new CommandAlias(this, rawCommand.aliasFor) : undefined;
        this.usages = valuesOrDefault(rawCommand.usage);
        this.examples = valuesOrDefault(rawCommand.example);
        this.summary = valueOrDefault(rawCommand.summary, "");
        this.description = valueOrDefault(rawCommand.description, "");
        this.container = rawCommand.container === true;
        this.help = valueOrDefault(rawCommand.help, false);
        this._preExec = rawCommand.preExec;
        this._postExec = rawCommand.postExec;
        this._exec = rawCommand.exec;
        this._lazyVisibility = Lazy.from(resolveVisibility, rawCommand, this.parentCommand);
        this._lazyCommandPath = Lazy.from(resolveCommandPath, this.commandName, this.parentCommand);
    }

    public get commandPath(): CommandPath {
        return this._lazyCommandPath.value;
    }

    public get visibility(): CommandLineVisibility {
        return this._lazyVisibility.value;
    }

    public get resolvedCommand(): Command {
        return this.aliasFor ? this.aliasFor.resolvedCommand : this;
    }

    public static compare(x: Command | undefined, y: Command | undefined): number {
        if (x === y) return 0;
        if (x === undefined) return -1;
        if (y === undefined) return +1;
        return compareValues(x.commandName, y.commandName)
            || compareValues(x.key, y.key);
    }

    public compareTo(other: Command | undefined): number {
        return Command.compare(this, other);
    }

    public isHelp(): this is HelpCommand {
        return this.help;
    }

    public toHierarchy(): HierarchyQuery<Command> {
        return from([this], commandHierarchy);
    }

    protected async _invokePreExec(parsed: ParsedCommandLine<any>, context: any) {
        if (!parsed.handled) {
            await super._invokePreExec(parsed, context);
            if (!parsed.handled && this._preExec) {
                const preExec = this._preExec;
                await preExec.call(this.rawCommand, parsed, context);
            }
        }
    }

    protected async _invokeExec(parsed: ParsedCommandLine<any>, context: any) {
        if (!parsed.handled) {
            if (this._exec) {
                const exec = this._exec;
                await exec.call(this.rawCommand, parsed, context);
                parsed.handled = true;
            }
            else {
                await super._invokeExec(parsed, context);
            }
        }
    }

    protected async _invokePostExec(parsed: ParsedCommandLine<any>, context: any) {
        if (parsed.handled) {
            if (this._postExec) {
                const postExec = this._postExec;
                await postExec.call(this.rawCommand, parsed, context);
            }
            await super._invokePostExec(parsed, context);
        }
    }
}

export type HelpCommand = Command & {
    help: true
};

export function normalizeName(name: string, caseInsensitive: boolean): string {
    if (name) {
        name = name.trim().replace(/_/g, "-");
        if (caseInsensitive) {
            name = name.toUpperCase();
        }
    }
    return name;
}

function normalizeNameCS(name: string) {
    return normalizeName(name, /*caseInsensitive*/ false);
}

function inferType(commandLineOption: CommandLineUnspecifiedOption): "boolean" | "number" | "string" {
    const type = commandLineOption.type;
    if (!type) {
        if (commandLineOption.passthru
            || commandLineOption.rest
            || commandLineOption.multiple
            || commandLineOption.required
            || typeof commandLineOption.position === "number") {
            return "string";
        }
        else {
            return "boolean";
        }
    }
    return type;
}

function checkCommandLineOption(key: string, type: "boolean" | "number" | "string", commandLineOption: CommandLineUnspecifiedOption) {
    const { longName, shortName, alias, aliasFor, single, multiple, passthru, rest, convert, help } = commandLineOption;
    switch (type) {
        case "boolean":
            if (multiple) throw Errors.optionCannotBeBothXAndY(key, "boolean", "multiple");
            if (passthru) throw Errors.optionCannotBeBothXAndY(key, "boolean", "passthru");
            if (rest) throw Errors.optionCannotBeBothXAndY(key, "boolean", "rest");
            if (convert) throw Errors.booleanOptionCannotHaveConverter(key);
            break;

        case "number":
        case "string":
            if (help) throw Errors.optionCannotBeBothXAndY(key, type, "help");
            if (aliasFor) throw Errors.optionCannotBeBothXAndY(key, type, "an alias for other options");
            break;
    }

    if (single) {
        if (multiple) throw Errors.optionCannotBeBothXAndY(key, "single", "multiple");
        if (rest) throw Errors.optionCannotBeBothXAndY(key, "single", "rest");
    }

    if (help) {
        if (multiple) throw Errors.optionCannotBeBothXAndY(key, "help", "multiple");
        if (rest) throw Errors.optionCannotBeBothXAndY(key, "help", "rest");
        if (passthru) throw Errors.optionCannotBeBothXAndY(key, "help", "passthru");
        if (aliasFor) throw Errors.optionCannotBeBothXAndY(key, "help", "an alias for other options");
    }

    if (longName) {
        if (/^$|\s/.test(longName.trim())) throw Errors.invalidLongName(key);
    }

    if (shortName) {
        if (shortName.trim().length !== 1) throw Errors.invalidShortName(key);
    }

    if (Array.isArray(alias)) {
        for (const aliasName of alias) {
            if (/^$|\s/.test(aliasName.trim())) throw Errors.invalidAlias(key);
        }
    }
    else if (alias) {
        if (/^$|\s/.test(alias.trim())) throw Errors.invalidAlias(key);
    }
}

function checkCommandLineCommand(key: string, commandLineCommand: CommandLineCommand) {
    const { help, container, exec, aliasFor, commands } = commandLineCommand;
    if (help) {
        if (aliasFor) throw Errors.commandCannotBeX(key, "a help command", "an alias for another command");
        if (container) throw Errors.commandCannotBeX(key, "a help command", "a container");
        if (commands) throw Errors.commandCannotHaveX(key, "a help command", "subcommands");
        if (exec) throw Errors.commandCannotHaveX(key, "a help command", "an 'exec' callback");
    }
    if (container) {
        if (exec) throw Errors.commandCannotHaveX(key, "a container-only command", "an 'exec' callback");
    }
    if (aliasFor) {
        if (commands) throw Errors.commandCannotHaveX(key, "an alias for another command", "subcommands");
        if (exec) throw Errors.commandCannotHaveX(key, "an alias for another command", "an 'exec' callback");
    }
}

function toCaseInsensitiveCommandLineValueMap<T extends string | number>(map: CommandLineValueMap<T>) {
    const mapCI: CommandLineValueMap<T> = {};
    for (const key of Object.keys(map)) {
        mapCI[key.toUpperCase()] = map[key];
    }
    return mapCI;
}

function asCommand(value: Resolver) {
    return value instanceof Command ? value : undefined;
}

function resolveVisibility(source: CommandLineOption | CommandLineOptionSet | CommandLineCommand, container: OptionSet | Command | undefined) {
    if (source.hidden === true) return "hidden";
    if (source.visibility !== undefined && source.visibility !== "inherit") return source.visibility;
    if (container !== undefined) return container.visibility;
    return "visible";
}

function resolveCommandAlias(resolver: Resolver, commandPath: ReadonlyArray<string>) {
    const result = walkCommandPath(resolver, commandPath);
    if (!result.found) throw new Error(`Could not resolve part of command: '${result.commandName}'`);
    return result.command;
}

function resolveCommandPath(commandName: string, parentCommand: Command | undefined): CommandPath {
    return parentCommand ? [...parentCommand.commandPath, commandName] as CommandPath : [commandName];
}

namespace Errors {
    export function invalidKey(key: string) {
        return captureStackTrace(new TypeError(`Invalid key: '${key}'.`), invalidKey);
    }
    export function invalidRawObject(key: string, kind: string) {
        return captureStackTrace(new TypeError(`Invalid ${kind} for key: '${key}'`), invalidRawObject);
    }
    export function invalidShortName(key: string) {
        return captureStackTrace(new Error(`Option '${key}' has an invalid short name. Short names may only be a single character.`), invalidShortName);
    }
    export function invalidLongName(key: string) {
        return captureStackTrace(new Error(`Option '${key}' has an invalid long name. Long names must be one or more characters with no whitespace.`), invalidLongName);
    }
    export function invalidAlias(key: string) {
        return captureStackTrace(new Error(`Option '${key}' has an invalid alias. Aliases must be one or more characters with no whitespace.`), invalidAlias);
    }
    export function optionCannotBeBothSingleAndMultiple(key: string) {
        return captureStackTrace(new Error(`Option '${key}' cannot be both single and multiple.`), optionCannotBeBothSingleAndMultiple);
    }
    export function restOptionCannotBeSingle(key: string) {
        return captureStackTrace(new Error(`Option '${key}' is declared as a rest option and cannot be single.`), restOptionCannotBeSingle);
    }
    export function helpOptionCannotBeMultiple(key: string) {
        return captureStackTrace(new Error(`Option '${key}' is declared as a help option and cannot be multiple.`), helpOptionCannotBeMultiple);
    }
    export function helpOptionCannotBeRest(key: string) {
        return captureStackTrace(new Error(`Option '${key}' is declared as a help option and cannot be declared as a rest option.`), helpOptionCannotBeRest);
    }
    export function helpOptionCannotBePassthru(key: string) {
        return captureStackTrace(new Error(`Option '${key}' is declared as a help option and cannot be declared as a passthru option.`), helpOptionCannotBePassthru);
    }
    export function booleanOptionCannotBeMultiple(key: string) {
        return captureStackTrace(new Error(`Option '${key}' of type 'boolean' cannot be multiple.`), booleanOptionCannotBeMultiple);
    }
    export function booleanOptionCannotBePassthru(key: string) {
        return captureStackTrace(new Error(`Option '${key}' of type 'boolean' cannot be passthru.`), booleanOptionCannotBePassthru);
    }
    export function booleanOptionCannotBeRest(key: string) {
        return captureStackTrace(new Error(`Option '${key}' of type 'boolean' cannot be rest.`), booleanOptionCannotBeRest);
    }
    export function booleanOptionCannotHaveConverter(key: string) {
        return captureStackTrace(new Error(`Option '${key}' of type 'boolean' cannot have a convert method.`), booleanOptionCannotHaveConverter);
    }
    export function stringOrNumberOptionCannotBeHelp(key: string, type: string) {
        return captureStackTrace(new Error(`Option '${key}' of type '${type}' cannot be help.`), stringOrNumberOptionCannotBeHelp);
    }
    export function optionOfTypeXCannotBeY(key: string, x: string, y: string) {
        return captureStackTrace(new Error(`Option '${key}' of type '${x}' cannot be ${y}.`), optionOfTypeXCannotBeY);
    }
    export function optionCannotBeBothXAndY(key: string, x: string, y: string) {
        return captureStackTrace(new Error(`Option '${key}' cannot be both ${x} and ${y}.`), optionCannotBeBothXAndY);
    }
    export function noConversionDefined(key: string) {
        return captureStackTrace(new Error(`Option '${key}' does not have a converter defined.`), noConversionDefined);
    }
    export function duplicateKey(key: string) {
        return captureStackTrace(new Error(`Duplicate key: '${key}'`), duplicateKey);
    }
    export function duplicateKind(kind: string, key: string, previousKey: string) {
        return captureStackTrace(new Error(`Duplicate ${kind} '${key}' conflicts with previous definition '${previousKey}'`), duplicateKind);
    }
    export function duplicateCommand(kind: string, commandName: string, key: string, previousKey: string) {
        return captureStackTrace(new Error(`Duplicate ${kind} '${commandName}' for command '${key}' conflicts with previous definition '${previousKey}'.`), duplicateCommand);
    }
    export function duplicatePosition(key: string, previousKey: string) {
        return captureStackTrace(new Error(`Option '${key}' specifies the same position as option '${previousKey}'.`), duplicatePosition);
    }
    export function duplicatePositionWithGroups(key: string, previousKey: string, groups: string[]) {
        return captureStackTrace(new Error(`Option '${key}' specifies the same position as option '${previousKey}' in ${formatList(groups, "group", "groups")}.`), duplicatePositionWithGroups);
    }
    export function commandCannotBeX(key: string, kind: string, other: string) {
        return captureStackTrace(new Error(`Command '${key}' is declared as ${kind} and cannot be ${other}.`), commandCannotBeX);
    }
    export function commandCannotHaveX(key: string, kind: string, other: string) {
        return captureStackTrace(new Error(`Command '${key}' is declared as ${kind} and cannot have ${other}.`), commandCannotHaveX);
    }
    export function containerCommandCannotHaveExec(key: string) {
        return captureStackTrace(new Error(`Command '${key}' is declared as a container command and cannot have an 'exec' callback.`), containerCommandCannotHaveExec);
    }
    function formatList(list: string[], singular: string, plural: string) {
        return `${list.length > 1 ? plural : singular} ${list.map(s => `"${s}"`).join(", ")}`;
    }
    function captureStackTrace<T extends Error>(error: T, stackCrawlMark: Function) {
        Error.captureStackTrace(error, stackCrawlMark);
        return error;
    }
}